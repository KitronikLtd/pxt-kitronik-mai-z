{"entries":[{"timestamp":1751447022213,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"0\" y=\"0\""],[0,"></b"]],"start1":67,"start2":67,"length1":20,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"205\" y=\"0\""],[0,"></b"]],"start1":107,"start2":107,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"Mai-Z.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":216,"start2":216,"length1":65,"length2":44}]},{"type":"added","filename":"Mai-Z.ts","value":"/**\n * Blocks for driving the kitronik Mai-Z the MouseBot for micro:bit\n */\n//% weight=100 color=#00A654 icon=\"\\uf1b9\" block=\"Mai-Z the MouseBot\"\n// subcategory=[\"More\"]\n//% group = '[\"Move\", \"Rotate\", \"Stop\", \"Tiles\", \"LEDs\", \"Functional Lighting\", \"Line Follow\", \"Front Distance\"]'\n\nnamespace kitronikMaiZ {\n    // Global Variables\n    // Movement\n    let distanceValue: number = 0; // Variable To Store Distance Value\n    const INCHES_CONSTANT: number = 2.54; // Inches To Centimeters Conversion Constant\n    const DISTANCE_CONSTANT: number = 100; // This Is To Avoid Decimals Not Being Sent As Parameters Are Sent At A Byte Level\n    let forwardContFlag: boolean = false; // Flag To Track Whether Forward Continuous Has Already Been Sent To Avoid Duplicate Messages Being Sent Over The I2C Comms\n    let leftContFlag: boolean = false; // Flag To Track Whether Left / Anti Clockwise Continuous Has Already Been Sent To Avoid Duplicate Messages Being Sent Over The I2C Comms\n    let rightContFlag: boolean = false; // Flag To Track Whether Right / Clockwise Continuous Has Already Been Sent To Avoid Duplicate Messages Being Sent Over The I2C Comms\n    // Sensors\n    let lineFollowValue: number = 0x00; // Line Following\n    let frontDistanceValue: number = 0x00; // Front Distance\n    let autoCliffEnabled: boolean = false; // Flag To Track Whether Auto CLif Detection Is Enabled, Used In The Logic To Avoid Duplicate Continuous Movement Commands\n    // Buzzer\n    let maizBuzzerPin: number = DigitalPin.P16 // On Board Mai-Z Buzzer Pin\n    // Errors\n    let errorStatus: number = 0x00; // Variable To Store Current Error Code\n    const ERROR_CONSTANT: number = 111;\n    // Manoeuvre Complete\n    let commandCompletedStatus: number = 0x00; // Variable To Store Command Completion Status\n    const COMMAND_OUTSTANDING: number = 0x01; // Command Outstanding Constant\n    // Units\n    let inchesFlag: boolean = false; // Flag To Track Whether Inches Is Requested\n    // Communication Retries\n    const MAX_RETRIES: number = 3; // Number Of Max Retries\n    // Communication Reset\n    let successfulCommsReset: boolean = false; // Flag To Track Whether Communication Is Successful After Failed Retries\n\n    // Look Up Tables\n    // Colour Picker IDs\n    const colourID: { [key: number]: number } = {\n        // Didn't Link When Formatted In Hexadecimal?\n        16711680: 0x01, // Red - 0xFF0000\n        16744448: 0x02, // Orange - 0xFF8000\n        16776960: 0x03, // Yellow - 0xFFFF00\n        16752037: 0x04, // Light Pink - 0xFF9DA5\n        65280: 0x05, // Green - 0x00FF00\n        11575039: 0x06, // Lilac - 0xB09EFF\n        65535: 0x07, // Cyan - 0x00FFFF\n        32767: 0x08, // Light Blue - 0x007FFF\n        6637343: 0x09, // Brown - 0x65471F\n        255: 0x0A, // Blue - 0x0000FF\n        8323327: 0x0B, // Violet - 0x7F00FF\n        16711808: 0x0C, // Pink - 0xFF0080\n        16711935: 0x0D, // Magenta - 0xFF00FF\n        16777215: 0x0E, // White - 0xFFFFFF\n        10066329: 0x0F, // Gray - 0x999999\n        0: 0x00  // Off/Black - 0x000000\n    };\n\n    // Colour Picker ID Mapper function\n    function colourIDMapper(colour: number): number {\n        return colourID[colour] || 0x00; // Return 0x00 If No Match\n    }\n\n    // General Enums\n    // Command IDs\n    export enum CommandID {\n        // Movement / Motor Driver\n        MOVE = 0x01,\n        SPIN = 0x02,\n        STOP = 0x03,\n        GRADUAL_STOP = 0x04,\n        TURN_ROVER = 0x05,\n        // ZIP LEDs\n        TURN_ALL_ZIP_LEDS = 0x10,\n        SET_ZIP_LED = 0x11,\n        SET_ZIP_LED_BRIGHTNESS = 0x12,\n        INDICATOR_LIGHT = 0x13,\n        BREAK_LIGHT = 0x14,\n        // Line Follow\n        LINE_FOLLOWING_DETECT = 0x20,\n        AUTO_CLIFF_DETECT = 0x22,\n        // Forward Distance\n        MEASURE_DISTANCE_FRONT = 0x21,\n        // Buzzer\n        SOUND_HORN = 0x30,\n        // Read Types\n        ERROR_READ = 0x40,\n        COMMAND_FINISHED_READ = 0x41,\n        // Comms Reset\n        COMMS_RESET = 0x50,\n        // Start Key\n        START_KEY = 0x60\n    }\n\n    // Command Types\n    export enum CommandType {\n        TxCommand = 0x00, // Transmit - micro:bit To Mai-Z\n        RxCommand = 0x01 // Receive - Mai-Z To micro:bit\n    }\n\n    // Error Codes\n    export enum ErrorCode {\n        // Mai-Z Side \n        NO_ERROR = 0x00,\n        TIMEOUT_ERROR = 0x01,\n        TX_CHECK_BYTE_ERROR = 0x02,\n        UNKOWN_COMMAND_ERROR = 0x03,\n        INVALID_DATA_ERROR = 0x04,\n        READ_ERROR = 0x05,\n        START_KEY_ERROR = 0x06,\n        CLIFF_DETECTED = 0x07,\n        // micro:bit Side\n        RX_CHECKBYTE_ERROR = 0x08,\n        RX_COMMAND_ERROR = 0x09,\n    }\n\n    // Block Enums\n    // Movement\n    /**\n     * Move Direction\n     */\n    export enum MoveDirection {\n        //% block=\"forwards\"\n        Forwards = 0x01,\n        //%block=\"reverse\"\n        Reverse = 0x02\n    }\n\n    /**\n     * Move Distance Options\n     */\n    export enum MoveDistance {\n        //% block=\"continuous\"\n        Continuous = 0x00,\n        //%block=\"1\"\n        OneUnit = 0x01,\n        //%block=\"2\"\n        TwoUnits = 0x02,\n        //%block=\"3\"\n        ThreeUnits = 0x03,\n        //%block=\"4\"\n        FourUnits = 0x04,\n        //%block=\"5\"\n        FiveUnits = 0x05,\n        //%block=\"10\"\n        TenUnits = 0x0A,\n        //%block=\"15\"\n        FiveteenUnits = 0x0E,\n        //%block=\"20\"\n        TwentyUnits = 0x14,\n        //%block=\"25\"\n        TwentyFiveUnits = 0x19,\n        //%block=\"50\"\n        FiftyUnits = 0x32,\n        //%block=\"100\"\n        OneHundredUnits = 0x64,\n        //%block=\"200\"\n        TwoHundredUnits = 0xC8,\n        //%block=\"500\"\n        FiveHundredUnits = 0x01F4,\n        //%block=\"1000\"\n        OneThousandUnits = 0x03E8,\n    }\n\n    /**\n     * Rotate Direction\n     */\n    export enum RotateDirection {\n        //% block=\"clockwise\"\n        Clockwise = 0x01,\n        //%block=\"anticlockwise\"\n        Anticlockwise = 0x02\n    }\n\n    // LEDs\n    /**\n     * LED ID\n     */\n    export enum LedID {\n        //% block=\"LED one\"\n        ledOne = 0x00,\n        //%block=\"LED two\"\n        ledTwo = 0x01,\n        //% block=\"LED three\"\n        ledThree = 0x02,\n        //%block=\"LED four\"\n        ledFour = 0x03,\n    }\n\n    /**\n     * LED Colours\n     */\n    export enum LedColours {\n        //% block=\"off\" \n        Off = 0x00,\n        //%block=\"red\" color=\"#FF0000\"\n        Red = 0x01,\n        //% block=\"yellow\" color=\"#FFFF00\"\n        Yellow = 0x02,\n        //%block=\"green\" color=\"#00FF00\"\n        Green = 0x03,\n        //% block=\"blue\" color=\"#0000FF\"\n        Blue = 0x04,\n        //%block=\"indigo\" color=\"#4B0082\"\n        Indigo = 0x05,\n        //% block=\"violet\" color=\"#8F00FF\"\n        Violet = 0x06,\n        //%block=\"purple\" color=\"#800080\"\n        Purple = 0x07,\n        //%block=\"white\" color=\"#FFFFFF\"\n        White = 0x08,\n    }\n\n    /**\n     * Indicator Status\n     */\n    export enum IndicatorStatus {\n        //% block=\"off\"\n        Off = 0x00,\n        //%block=\"left\"\n        Left = 0x01,\n        //%block=\"right\"\n        Right = 0x02,\n        //%block=\"hazards\"\n        Hazards = 0x03\n    }\n\n    /**\n     * Brake Status\n     */\n    export enum BrakeStatus {\n        //% block=\"off\"\n        Off = 0x00,\n        //%block=\"on\"\n        On = 0x01,\n    }\n\n    // Sensors\n    /**\n     * Line Follow Status\n     */\n    export enum LineFollowSensor {\n        //% block=\"right\"\n        Right = 0x01,\n        //%block=\"centre\"\n        Centre = 0x02,\n        //%block=\"left\"\n        Left = 0x04\n    }\n\n    /**\n     * Auto Cliff Detection Status\n     */\n    export enum AutoCliffStatus {\n        //% block=\"enabled\"\n        Enabled = 0x01,\n        //%block=\"disabled\"\n        Disabled = 0x00\n    }\n\n    // Tile Movement\n    /**\n     * Move Forwards X Tiles\n     */\n    export enum MoveXTiles {\n        //% block=\"one\"\n        OneTile = 0x01,\n        //%block=\"two\"\n        TwoTiles = 0x02,\n        //% block=\"three\"\n        ThreeTiles = 0x03,\n        //%block=\"four\"\n        FourTiles = 0x04,\n        //% block=\"five\"\n        FiveTiles = 0x05,\n        //% block=\"six\"\n        SixTiles = 0x06,\n        //%block=\"seven\"\n        SevenTiles = 0x07,\n        //% block=\"eight\"\n        EightTiles = 0x08,\n        //%block=\"nine\"\n        NineTiles = 0x09,\n        //% block=\"ten\"\n        TenTiles = 0x10,\n        //% block=\"eleven\"\n        ElevenTiles = 0x11,\n        //%block=\"twelve\"\n        TwelveTiles = 0x12\n    }\n    /**\n     * Turn For Tiles\n     */\n    export enum TurnTiles {\n        //% block=\"right\"\n        TurnRight = 0x01,\n        //%block=\"left\"\n        TurnLeft = 0x02,\n    }\n\n    // Units\n    /**\n     * Select Units\n     */\n    export enum SelectUnits {\n        //% block=\"cm\"\n        Cm = 0x00,\n        //%block=\"inches\"\n        Inches = 0x01\n    }\n\n\n    // Buzzer Set Up\n    pins.setAudioPin(maizBuzzerPin); // Set Buzzer To Mai-Z Buzzer Pin\n    // Start Key Initialisation\n    txMessage(CommandID.START_KEY, []); // Send Start Key Over Comms\n\n\n    // Blocks\n\n    // Movement\n    ////////////////\n    ///Move-MaiZ///\n    ////////////////\n\n    /**\n     * move mai-z [direction], [speed], [distance]: moves mai-z in the relevant direction, at the relevant speed, over the relevant distance\n     * @param direction : forwards - moves mai-z motors forwards. reverse - moves mai-z motors in reverse / backwards.\n     * @param distance: 0 / continuous - infinitely moves mai-z. distance to move in cm/inches.\n     * @param speed: speed in terms of a percentage e.g. 1 - 100.\n     */\n    //% blockId=maiz_move\n    //% block=\"move $movedirection at $speed\\\\% speed for $distance\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Move\"\n    //% subcategory=\"Movement\"\n    //% speed.min=1 speed.max=100 speed.defl=50\n    //% speed.fieldOptions.precision=1\n    export function maizMove(movedirection: MoveDirection, speed: number, distance: MoveDistance): void {\n        // Extract Distance Value\n        distanceValue = ((distance as number) * DISTANCE_CONSTANT);\n        // Check If Continuous Is Entered\n        if (distanceValue == MoveDistance.Continuous) {\n            // Check If Command Has Already Been Set\n            if (!forwardContFlag) {\n                // Send Move Command And Parameters\n                commsRetries(CommandID.MOVE, [(movedirection as number), speed, distanceValue], CommandType.TxCommand);\n                // Set Forwards Continuous Flag\n                forwardContFlag = true; // Reset On Stop Commands / New Movement Commands Auto Cliff Detection Handled Separately (If Statement Below)\n            }\n            else if (autoCliffEnabled) {\n                // Send Error Read To Check For Cliff Status\n                rxMessage(CommandID.ERROR_READ)\n                // If No Error\n                if (errorStatus === ErrorCode.NO_ERROR) {\n                    return;  // Continuous Movement Still Okay, Do Not Send Duplicate Command \n                }\n                // If A Cliff Detected\n                if (errorStatus === ErrorCode.CLIFF_DETECTED) {\n                    // Re Send Move Continuous Command As Auto Cliff Stopped Movement, Flag Can Stay Set As Movement Being Re Called\n                    commsRetries(CommandID.MOVE, [(movedirection as number), speed, distanceValue], CommandType.TxCommand);\n                }\n            }\n        }\n        // If Distance Entered\n        else {\n            // Check If Inches Unit Is Set\t\n            if (inchesFlag) {\n                distanceValue = distanceValue * INCHES_CONSTANT;\n            }\n            // Convert Distance To Bytes\n            const distanceArray = intToByte(distanceValue);\n            // Send MoveCommand And Parameters\n            commsRetries(CommandID.MOVE, [(movedirection as number), speed].concat(distanceArray), CommandType.TxCommand);\n            // Reset Continuous Flags\n            forwardContFlag = false;\n            rightContFlag = false;\n            leftContFlag = false;\n            // Send Manoeuvre Complete Read Command \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n            // Wait Until Manoeuvre Complete Signal Received\n            while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n                // Send Manoeuvre Complete Read Command  \n                commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n                // 10ms Delay - Prevent Overload\n                basic.pause(10);\n            }\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    /////////////////////////////\n    ///Rotate-MaiZ-Continuous///\n    /////////////////////////////\n\n    /**\n     * rotate mai-z [direction], [speed], [angle]: Rotates mai-z in the relevant direction, at the relevant speed, over the relevant angle\n     * @param direction : left - rotates mai-z left. right - rotates mai-z right.\n     * @param speed: speed in terms of a percentage e.g. 1 - 100.\n     * @param angle: 0 / continuous - infinetly rotates mai-z. angle to move in degrees.\n     */\n    //% blockId=maiz_rotate_continuous\n    //% block=\"rotate $rotatedirection continuously at $speed\\\\% speed\"\n    //% weight=90 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Rotate\"\n    //% subcategory=\"Movement\"\n    //% speed.min=1 speed.max=100 speed.defl=50\n    //% speed.fieldOptions.precision=1\n    export function maizRotateContinuous(rotatedirection: RotateDirection, speed: number): void {\n        // Check Requested Direction\n        const clockwiseFlag = (rotatedirection === RotateDirection.Clockwise);\n        // Check If Requested Direction Is Already Active\n        const activeFlag = clockwiseFlag ? rightContFlag : leftContFlag;\n        // If Requested Direction Not Active Call Movement As Normal\n        if (!activeFlag) {\n            // Check If The Requested Command Has Already Been Sent, If So Return To Avoid Duplicate Commands Being Sent Over The I2C Line\n            if (rotatedirection === RotateDirection.Clockwise && rightContFlag) return;\n            if (rotatedirection === RotateDirection.Anticlockwise && leftContFlag) return;\n            // Reset Flags For The New Command Call\n            rightContFlag = false;\n            leftContFlag = false;\n            // Send Rotate (Spin) Command And Parameters\n            commsRetries(CommandID.SPIN, [(rotatedirection as number), speed, MoveDistance.Continuous], CommandType.TxCommand);\n            // Set Flag Based On New Command Sent\n            if (rotatedirection === RotateDirection.Clockwise) {\n                rightContFlag = true; // Reset On Stop Commands / New Direction\n            }\n            else {\n                leftContFlag = true; // Reset On Stop Commands / New Direction\n            }\n        }\n        else if (autoCliffEnabled) {\n            // Send Error Read To Check For Cliff Status\n            rxMessage(CommandID.ERROR_READ)\n            // If No Error\n            if (errorStatus === ErrorCode.NO_ERROR) {\n                return;  // Continuous Movement Still Okay, Do Not Send Duplicate Command \n            }\n            // If A Cliff Detected\n            if (errorStatus === ErrorCode.CLIFF_DETECTED) {\n                // Re Send Move Continuous Command As Auto Cliff Stopped Movement, Flag Can Stay Set As Movement Being Re Called\n                commsRetries(CommandID.SPIN, [(rotatedirection as number), speed, MoveDistance.Continuous], CommandType.TxCommand);\n            }\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    ////////////////////////\n    ///Rotate-MaiZ-Angle///\n    ////////////////////////\n\n    /**\n     * rotate mai-z [anlge], [speed]: Rotates mai-z over the relevant angle in the relevant direction (decided by the angle), at the relevant speed\n     * @param direction : left - rotates mai-z left. right - rotates mai-z right.\n     * @param speed: speed in terms of a percentage e.g. 1 - 100.\n     * @param angle: 0 / continuous - infinitely rotates mai-z. angle to move in degrees.\n     */\n    //% blockId=maiz_rotate_angle\n    //% block=\"rotate $rotateratio at $speed\\\\% speed\"\n    //% weight=80 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Rotate\"\n    //% subcategory=\"Movement\"\n    //% rotateratio.min=-180 rotateratio.max=180 \n    //% rotateratio.fieldOptions.precision=10\n    //% rotateratio.shadow=turnRatioPicker\n    //% speed.min=1 speed.max=100 speed.defl=50\n    //% speed.fieldOptions.precision=1\n    export function maizRotateAngle(rotateratio: number, speed: number): void {\n        // Extract Direction Based On If rotateratio Is + or -\n        let rotateDirection = rotateratio > 0 ? RotateDirection.Clockwise : RotateDirection.Anticlockwise;\n        // Extract Distance Value\n        distanceValue = (Math.abs(rotateratio) * DISTANCE_CONSTANT);\n        // Check If Inches Unit Is Set\t\n        if (inchesFlag) {\n            distanceValue = distanceValue * INCHES_CONSTANT;\n        }\n        // Convert Distance To Bytes\n        const distanceArray = intToByte(distanceValue);\n        // Send Rotate (Spin) Command And Parameters\n        commsRetries(CommandID.SPIN, [(rotateDirection as number), speed].concat(distanceArray), CommandType.TxCommand); // Pass The Angle As A Positive Number/Unsigned Integer\n        // Reset Continuous Flags\n        forwardContFlag = false;\n        rightContFlag = false;\n        leftContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    /////////////////////////\n    ///Full-Mai-Z-Rotation///\n    /////////////////////////\n\n    /**\n     * 360 rotation: turns mai-z a full 360 degree rotation in the chosen direction at the chosen speed\n     * @param direction : left - rotates mai-z left/anticlockwise. right - rotates mai-z right/clockwise.\n     */\n    //% blockId=maiz_360_rotation\n    //% block=\"rotate 360 degrees in $rotatedirection direction at $speed\\\\% speed\"\n    //% weight=70                    \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Rotate\"\n    //% subcategory=\"Movement\"\n    export function maiz360Rotation(rotatedirection: RotateDirection, speed: number): void {\n        // Send Turn Command And Parameters\n        commsRetries(CommandID.SPIN, [(rotatedirection as number), speed, 0xA0, 0x8c], CommandType.TxCommand); // Pass The Chosen Direction With A Angle Of 360 (0xA0, 0x8C = 18000 In Hex) And A Speed Of 1%\n        // Reset Continuous Flags\n        forwardContFlag = false;\n        rightContFlag = false;\n        leftContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    ////////////////\n    ///Stop-MaiZ///\n    ////////////////\n\n    /**\n     * instantly stop maiz movement\n     */\n    //% blockId=maiz_stop\n    //% block=\"stop\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Stop\"\n    //% subcategory=\"Movement\"\n    export function maizStop(): void {\n        // Send Stop Command\n        commsRetries(CommandID.STOP, [], CommandType.TxCommand);\n        // Reset Continuous Flags\n        rightContFlag = false;\n        leftContFlag = false;\n        forwardContFlag = false;\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    ////////////////////////\n    ///Gradual-Stop-MaiZ///\n    ////////////////////////\n\n    /**\n     * gradually stop maiz by steadily decreasing speed to zero\n     */\n    //% blockId=maiz_gradual_stop\n    //% block=\"gradual stop\"\n    //% weight=90 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Stop\"\n    //% subcategory=\"Movement\"\n    export function maizGradualStop(): void {\n        // Send Gradual Stop Command\n        commsRetries(CommandID.GRADUAL_STOP, [], CommandType.TxCommand);\n        // Reset Continuous Flags\n        rightContFlag = false;\n        leftContFlag = false;\n        forwardContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    ////////////////\n    ///Move-Tiles///\n    ////////////////\n\n    /**\n     * move mai-z over [number of tiles] at [speed]: moves mai-z over the selected number of tiles at the relevant speed\n     * @param number of tiles : amount of tiles to move across.\n     * @param speed: speed in terms of a percentage e.g. 1 - 100.\n     */\n    //% blockId=maiz_move_tiles\n    //% block=\"move $movextiles tiles at $speed\\\\% speed\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Tiles\"\n    //% subcategory=\"Movement\"\n    //% speed.min=1 speed.max=100 speed.defl=50\n    //% speed.fieldOptions.precision=1\n    export function maizMoveTiles(movextiles: MoveXTiles, speed: number): void {\n        // Extract Distance Value\n        distanceValue = ((movextiles as number) * 13.5 * DISTANCE_CONSTANT); // 13.5 - Distance Of One Tile\n        // Convert Distance To Bytes\n        const distanceArray = intToByte(distanceValue);\n        // Send MoveCommand And Parameters\n        commsRetries(CommandID.MOVE, [(MoveDirection.Forwards), speed].concat(distanceArray), CommandType.TxCommand);\n        // Reset Continuous Flags\n        forwardContFlag = false;\n        rightContFlag = false;\n        leftContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    ////////////////\n    ///Turn-Tiles///\n    ////////////////\n\n    /**\n     * turn [direction]: turns mai-z ninety degrees left or right, for use with tiles set\n     * @param direction : left - rotates mai-z left/anticlockwise. right - rotates Mai-z right/clockwise.\n     */\n    //% blockId=maiz_turn_tiles\n    //% block=\"turn $tileturndirection\"\n    //% weight=90 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Tiles\"\n    //% subcategory=\"Movement\"\n    export function maizTurnTiles(tileturndirection: TurnTiles): void {\n        // Send Turn Command And Parameters\n        commsRetries(CommandID.SPIN, [(tileturndirection as number), 1, 0x28, 0x23], CommandType.TxCommand); // Pass The Chosen Direction With A Angle Of 90 (0x28, 0x23 = 900 In Hex) And A Speed Of 1%\n        // Reset Continuous Flags\n        forwardContFlag = false;\n        rightContFlag = false;\n        leftContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    //////////////////\n    ///U-Turn-Tiles///\n    //////////////////\n\n    /**\n     * u turn: turns mai-z one hundred and eighty degrees, for use with the tile set\n     * @param direction : left - rotates mai-z left/anticlockwise. right - rotates mai-z right/clockwise.\n     */\n    //% blockId=maiz_u_turn\n    //% block=\"u turn\"\n    //% weight=80 \n    //% blockGap=8\n    //% color=#00A654\n    //% group=\"Tiles\"\n    //% subcategory=\"Movement\"\n    export function maizUTurn(): void {\n        // Send Turn Command And Parameters\n        commsRetries(CommandID.SPIN, [(RotateDirection.Clockwise), 1, 0x50, 0x46], CommandType.TxCommand); // Pass The Chosen Direction With A Angle Of 180 (0x50, 0x46 = 1800 In Hex) And A Speed Of 1%\n        // Reset Continuous Flags\n        forwardContFlag = false;\n        rightContFlag = false;\n        leftContFlag = false;\n        // Send Manoeuvre Complete Read Command \n        commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n        // 10ms Delay - Prevent Overload\n        basic.pause(10);\n        // Wait Until Manoeuvre Complete Signal Received\n        while (commandCompletedStatus == COMMAND_OUTSTANDING) {\n            // Send Manoeuvre Complete Read Command  \n            commsRetries(CommandID.COMMAND_FINISHED_READ, [], CommandType.RxCommand);\n            // 10ms Delay - Prevent Overload\n            basic.pause(10);\n        }\n        // Short Pause\n        basic.pause(100); // Allows For Movements / Motors To Be Completely Stopped Before Any Subsequent Commands Are Called\n    }\n\n    // LEDs\n    //////////////\n    ///Set-LEDs///\n    //////////////\n\n    /**\n     * set LEDs to [colour]: sets the relevant LED to the relevant colour\n     * @param colour: colour of led (8 colours, off)\n     */\n    //% blockId=set_leds\n    //% block=\"set LEDs to $ledcolours\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#996DAD\n    //% group=\"LEDs\"\n    //% subcategory=\"LEDs\"\n    //% ledcolours.shadow=\"colorNumberPicker\"\n    export function setLEDs(ledcolours: number): void {\n        // Send Set LEDs Command And Parameter\n        commsRetries(CommandID.TURN_ALL_ZIP_LEDS, [colourIDMapper(ledcolours)], CommandType.TxCommand);  // Pass The Colour Number Mapped As A Command ID\n    }\n\n    /////////////\n    ///Set-LED///\n    /////////////\n\n    /**\n     * set LED [LedID] to [colour]: sets the relevant LED to the relevant colour\n     * @param LedID: id of led (1-4)\n     * @param colour: colour of led (8 colours, off)\n     */\n    //% blockId=set_led\n    //% block=\"set $ledid to $ledcolours\"\n    //% weight=90 \n    //% blockGap=8\n    //% color=#996DAD\n    //% group=\"LEDs\"\n    //% subcategory=\"LEDs\"\n    //% ledcolours.shadow=\"colorNumberPicker\"\n    export function setLED(ledid: LedID, ledcolours: number): void {\n        // Send Set LED Command And Parameters\n        commsRetries(CommandID.SET_ZIP_LED, [(ledid as number), colourIDMapper(ledcolours)], CommandType.TxCommand); // Pass The Colour Number Mapped As A Command ID\n    }\n\n    ////////////////////\n    ///Set-Brightness///\n    ////////////////////\n\n    /**\n     * set LED brightness [LedBrightness]\n     * @param LedBrightness: brightness of led as a percentage (1-100)\n     */\n    //% blockId=set_led_brightness\n    //% block=\"set LED brightness to $ledbrightness\\\\%\"\n    //% weight=80 \n    //% blockGap=8\n    //% color=#996DAD\n    //% group=\"LEDs\"\n    //% subcategory=\"LEDs\"\n    //% ledbrightness.min=1 ledbrightness.max=100\n    //% ledid.fieldOptions.precision=1\n    export function setLEDBrightness(ledbrightness: number): void {\n        // Map Brightness To 0 - 255 Scale\n        let mappedBrightness = ((ledbrightness * 128) / 100);\n        // Send LED Brightness Command And Mapped Parameter\n        commsRetries(CommandID.SET_ZIP_LED_BRIGHTNESS, [mappedBrightness], CommandType.TxCommand);\n    }\n\n    //////////////////////////\n    ///Set-Indicator-Lights///\n    //////////////////////////\n\n    /**\n     * set indicator lights to [indicatorstatus]\n     * @param indicatorstatus: status of indicator lights (left, right, hazards, off)\n     */\n    //% blockId=set_indicator_lights\n    //% block=\"set indicator lights to $indicatorstatus\"\n    //% weight=70 \n    //% blockGap=8\n    //% color=#996DAD\n    //% group=\"Functional Lighting\"\n    //% subcategory=\"LEDs\"\n    export function setIndicatorLights(indicatorstatus: IndicatorStatus): void {\n        // Send Indicator Command\n        commsRetries(CommandID.INDICATOR_LIGHT, [indicatorstatus as number], CommandType.TxCommand);\n    }\n\n    //////////////////////\n    ///Set-Brake-Lights///\n    //////////////////////\n\n    /**\n     * set brake lights to [breakstatus]\n     * @param brakestatus: status of break lights (on, off)\n     */\n    //% blockId=set_break_lights\n    //% block=\"set brake lights to $brakestatus\"\n    //% weight=60 \n    //% blockGap=8\n    //% color=#996DAD\n    //% group=\"Functional Lighting\"\n    //% subcategory=\"LEDs\"\n    export function setBrakeLights(brakestatus: BrakeStatus): void {\n        // Send Break Light Command\n        commsRetries(CommandID.BREAK_LIGHT, [brakestatus as number], CommandType.TxCommand);\n    }\n\n    //Sensors\n    ////////////////////////\n    ///Line-Follow-Status///\n    ////////////////////////\n\n    /**\n     * return [linefollowsensor] status as true or false\n     * @param linefollowsensor: select which line follow sensor status to return (left, centre, right)\n     */\n    //% blockId=line_follow_status\n    //% block=\"$linefollowsensor line follow sensor status\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00ADE5\n    //% group=\"Line Follow\"\n    //% subcategory=\"Sensors\"\n    export function lineFollowStatus(linefollowsensor: LineFollowSensor): boolean {\n        // Send Line Follow Command (Returns Status Of 3 Line Detect And Cliff Detection)\n        commsRetries(CommandID.LINE_FOLLOWING_DETECT, [], CommandType.RxCommand);\n        // Extract Which Sensor User Has Selected\n        let sensorSelect = linefollowsensor as number;\n        // Extract Cliff Detection Bit Using Bit Mask\n        let lineFollowStatus = (lineFollowValue & sensorSelect);\n        // Return Boolean Cast Of Bit\n        return !!lineFollowStatus;\n    }\n\n    ////////////////////////////\n    ///Cliff-Detection-Status///\n    ////////////////////////////\n\n    /**\n     * return cliff detection status as true or false\n     */\n    //% blockId=cliff_detection_status\n    //% block=\"cliff detection status\"\n    //% weight=90\n    //% blockGap=8\n    //% color=#00ADE5\n    //% group=\"Line Follow\"\n    //% subcategory=\"Sensors\"\n    export function cliffDetectionStatus(): boolean {\n        // Send Line Follow Command (Returns Status Of 3 Line Detect And Cliff Detection) \n        commsRetries(CommandID.LINE_FOLLOWING_DETECT, [], CommandType.RxCommand);\n        // Extract Cliff Detection Bit Using Bit Mask\n        let cliffDetectStatus = (lineFollowValue >> 3) & 0x01;\n        // Return Boolean Cast Of Bit\n        return !!cliffDetectStatus\n    }\n\n    ////////////////////////////\n    ///Auto-Cliff-Detection///\n    ////////////////////////////\n\n    /**\n     * automatic cliff detection status. when enabled this automatically stops the motors and further command processing once a cliff is detected\n     */\n\n    //% blockId=auto_cliff_detection\n    //% block=\"auto cliff detection $autocliffstatus\"\n    //% weight=80 \n    //% blockGap=8\n    //% color=#00ADE5\n    //% group=\"Line Follow\"\n    //% subcategory=\"Sensors\"\n    export function autoCliffDetection(autocliffstatus: AutoCliffStatus): void {\n        // Send Auto Cliff Detection Status\n        commsRetries(CommandID.AUTO_CLIFF_DETECT, [autocliffstatus as number], CommandType.TxCommand);\n        // Set Flag Based On The Auto Cliff Status\n        if (autocliffstatus === AutoCliffStatus.Enabled) autoCliffEnabled = true;\n        else autoCliffEnabled = false;\n    }\n\n    ////////////////////\n    ///Front-Distance///\n    ////////////////////\n\n    /**\n     * measure front distance (2 - 200 cm)\n     */\n    //% blockId=front_distance\n    //% block=\"measure front distance\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00ADE5\n    //% group=\"Front Distance\"\n    //% subcategory=\"Sensors\"\n    export function measureFrontDistance(): number {\n        // Send Forward Distance Command\n        commsRetries(CommandID.MEASURE_DISTANCE_FRONT, [], CommandType.RxCommand);\n        // Check If Inches Is Required\n        if (inchesFlag) {\n            // Return Distance Value In Inches\n            return Math.trunc(frontDistanceValue / INCHES_CONSTANT);\n        }\n        // Return Front Distance Value\n        return Math.trunc(frontDistanceValue);\n    }\n\n    // Buzzer\n    ////////////////\n    ///Sound-Horn///\n    ////////////////\n    /**\n     * sound mai-z buzzer, double beep\n     */\n    //% blockId=sound_horn\n    //% block=\"beep horn\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#00A79D\n    //% subcategory=\"Buzzer\"\n    export function soundBuzzer(): void {\n        // Send Sound Horn Command\n        commsRetries(CommandID.SOUND_HORN, [], CommandType.TxCommand);\n    }\n\n    // Units\n    //////////////////\n    ///Units-Select///\n    //////////////////\n\n    /**\n     * measure in [units] (cm by default)\n     * @param units: select what units to measure in (cm, inches)\n     */\n    //% blockId=units_select\n    //% block=\"measure in $selectunits\"\n    //% weight=100 \n    //% blockGap=8\n    //% color=#EE3D96\n    //% subcategory=\"Units\"\n    export function unitsSelect(selectunits: SelectUnits): void {\n        // Set Flag To Boolean Cast Of Input\n        inchesFlag = !!selectunits;\n    }\n\n    // General Functions\n\n    // Int to Byte Function - Convert Integers To Bytes\n    // ---------------------------------------------------------\n    // Purpose: Take Parameter Values and Convert To Bytes Ready\n    // To Be Processed Into An I2C Message\n    // ---------------------------------------------------------\n    // Inputs: Parameter Value\n    // ---------------------------------------------------------\n    // Outputs: Array Of Bytes \n    // ---------------------------------------------------------\n\n    export function intToByte(parameterValue: number): number[] {\n        // Define Array To Store Bytes in\n        let parameterArray = [];\n        // Loop Until Parameter Value Completely Processed\n        while (parameterValue > 0) {\n            // Extract The Least Significant Byte And Push To Array\n            parameterArray.push(parameterValue & 0xFF);\n            // Shift The Parameter Value Right By A Byte/8Bits\n            parameterValue >>= 8;\n        }\n        // Return Byte Array\n        return parameterArray;\n    }\n\n    // Calculate Check Byte Function - Calculate I2C Message Check Bytes\n    // ------------------------------------------------------------------\n    // Purpose: Calculate Message Check Byte By Taking The Total Of The \n    // Message Bytes And Inverting The Value, The Least Significant Byte \n    // Is Then Taken\n    // ------------------------------------------------------------------\n    // Inputs: Message Array\n    // ------------------------------------------------------------------\n    // Outputs: Check Byte\n    // ------------------------------------------------------------------\n\n    export function calculateCheckByte(message: number[]): number {\n        // Calculate Check Byte\n        let checkByte = 0;\n        // Total Message Array Bytes\n        for (let i = 0; i < message.length; i++) { // Loop Through Message Array\n            // Sum Current Message Array Byte\n            checkByte += message[i];\n        }\n        // Invert Check Byte And Extract Least Significant Byte\n        checkByte = ~checkByte & 0xFF;\n        // Return Calculated Check Byte\n        return checkByte;\n    }\n\n    // Tx Function - Prepare and Send I2C Communication Messages\n    // ---------------------------------------------------------\n    // Purpose: Take Commands and Relevant Parameters and Format \n    // Into an Array, Then Send The Message To Mai-Z\n    // ---------------------------------------------------------\n    // Inputs: Command ID, Relevant Parameters\n    // ---------------------------------------------------------\n    // Outputs: Void / Send Prepared Message To Mai-Z Over I2C \n    // ---------------------------------------------------------\n\n    export function txMessage(commandID: number, commandParameters: number[]) {\n        // Calculate Message Length\n        const txMessageLength = (commandParameters.length + 2); // Number Of Parameters + 1 For Command ID + 1 For Check Byte\n        // Initialise Message Array With Data\n        const messageArray = [txMessageLength, commandID];\n        // Push Command Parameters To The End Of The Message Array\n        for (let i = 0; i < commandParameters.length; i++) {// Loop Through All Command Parameters\n            messageArray.push(commandParameters[i]); // Push Current Command Parameter To End Of Message Array\n        }\n        // Calculate Check Byte\n        let txCheckByte = calculateCheckByte(messageArray);\n        // Add Calculated Check Byte To End Of Message Array\n        messageArray.push(txCheckByte);\n        // Send Message Over I2C\n        pins.i2cWriteBuffer(23, pins.createBufferFromArray(messageArray));\n    }\n\n    // Rx Function - Receive and Process I2C Communication Messages\n    // ------------------------------------------------------------\n    // Purpose: Take Receive Commands And Request Relevant Data \n    // From Mai-Z, Then Process The Data And Store In \n    // Corresponding Global Variables\n    // ---------------------------------------------------------\n    // Inputs: Command ID\n    // ---------------------------------------------------------\n    // Outputs: Void / Save Relevant Data To Global Variables \n    // ---------------------------------------------------------\n\n    export function rxMessage(readID: number) {\n        // Send Read Command Message\n        txMessage(readID, []);\n        // Declare Rx Data Buffer\n        let rxDataBuffer: Buffer;\n        // Check Command ID For Front Distance\n        if (readID == CommandID.MEASURE_DISTANCE_FRONT) { // Front Distance Requires 5 Bytes\n            // Request And Store Rx Data\n            rxDataBuffer = pins.i2cReadBuffer(23, 5, false)// Request 5 Bytes\n        }\n        else {\n            // Request And Store Rx Data\n            rxDataBuffer = pins.i2cReadBuffer(23, 4, false)// Request 4 Bytes (All Other Read Types Require 4 Bytes Of Data)\n        }\n        // Process Received Data\n        // Extract Received Message Length\n        const rxMessageLength = rxDataBuffer.length;\n        // Extract All Data Apart From Check Byte\n        let rxCheckByteData: number[] = []; // Initialise Empty Array\n        for (let i = 0; i <= rxMessageLength - 2; i++) {\n            rxCheckByteData.push(rxDataBuffer[i]); // Push All Data Apart From Check Byte\n        }\n\n        // Calculate Check Byte  \n        const rxCheckByte = calculateCheckByte(rxCheckByteData); // Send Rx Message Without Check Byte\n        // Compare Calculated and Received Check Bytes\n        if (rxCheckByte != rxDataBuffer[rxMessageLength - 1]) {\n            // Set Error Status To Check Byte Error\n            errorStatus = ErrorCode.RX_CHECKBYTE_ERROR;\n            // Stop Processing\n            return;\n        }\n        // Extract Packet Type/Command ID\n        const rxCommandID = rxDataBuffer[1];\n        // Check Expected Command ID Was Received\n        if (rxCommandID != readID) {\n            // Set Error Status To Command Error\n            errorStatus = ErrorCode.RX_COMMAND_ERROR;\n            return;\n        }\n        // Extract Relevant Data Based On Command ID\n        switch (rxCommandID) {\n            // Line Follow Status\n            case CommandID.LINE_FOLLOWING_DETECT: {\n                // Extract Command Completed Status\n                lineFollowValue = rxDataBuffer[2]; // 3rd Byte Is Where Relevant Data Is Stored\n                return;\n            }\n            // Front Distance Value\n            case CommandID.MEASURE_DISTANCE_FRONT: {\n                // Extract Command Completed Status\n                frontDistanceValue = ((((rxDataBuffer[3] << 8) | rxDataBuffer[2]) / 100) - 2); // 3rd Byte Is Where Relevant Data Is Stored\n                return;\n            }\n            // Error Status\n            case CommandID.ERROR_READ: {\n                // Extract Command Completed Status\n                errorStatus = rxDataBuffer[2]; // 3rd Byte Is Where Relevant Data Is Stored\n                return;\n            }\n            // Command Completed Status\n            case CommandID.COMMAND_FINISHED_READ: {\n                // Extract Command Completed Status\n                commandCompletedStatus = rxDataBuffer[2]; // 3rd Byte Is Where Relevant Data Is Stored\n                return;\n            }\n            // Command Comms Reset\n            case CommandID.COMMS_RESET: {\n                // Check If Comms Reset Was Successful\n                if (rxDataBuffer[2] == 0x02) {\n                    // Set Comms Reset Flag\n                    successfulCommsReset = true;\n                    return;\n                }\n            }\n        }\n    }\n\n    // Communication Retries Function - \n    // Send/Receive Commands With Retries Where Applicable To Avoid Errors\n    // ------------------------------------------------------------------\n    // Purpose: Take Commands And Parameters And Send To Mai-Z, If \n    // Errors Are Returned Retry To A Max Of 3 Tries\n    // ------------------------------------------------------------------\n    // Inputs: Command ID, Parameters, Tx/Rx \n    // ------------------------------------------------------------------\n    // Outputs: Void / Error Codes\n    // ------------------------------------------------------------------\n    export function commsRetries(commandID: number, commandParameters: number[], commsType: CommandType) {\n        // Define Variables\n        let retriesCounter: number = 0; // Retries Counter\n        // Retries Loop\n        while (retriesCounter <= MAX_RETRIES) {\n            // Check Command Type And Send Command To Relevant Function\n            if (commsType == CommandType.TxCommand) { // Tx Command\n                // Send Command And Parameters To Tx Function\n                txMessage(commandID, commandParameters);\n            }\n            else if (commsType == CommandType.RxCommand) { // Rx Command\n                // Send Command And Parameters To Rx Function\n                rxMessage(commandID);\n            }\n            // Send Error Read Command\n            rxMessage(CommandID.ERROR_READ);\n            // Check Error Status\n            if (errorStatus == ErrorCode.NO_ERROR) { // Command Sent With No Errors\n                // Return/Break Out Of Function\n                return;\n            }\n            else if (errorStatus == ErrorCode.START_KEY_ERROR) {\n                // Reset Error Status\n                errorStatus = ErrorCode.NO_ERROR;\n                // Reset Micro:bit\n                control.reset();\n            }\n            else if (errorStatus == ErrorCode.CLIFF_DETECTED) {\n                // Loop Until Cliff Is Not Detected/Floor Detected\n                while (errorStatus == ErrorCode.CLIFF_DETECTED) {\n                    // Short Pause Between Retry Attempts\n                    basic.pause(5);\n                    // Retry Error Read\n                    rxMessage(CommandID.ERROR_READ); // Send Error Read Command\n                }\n                // Short Pause Before Carrying On Commands\n                basic.pause(500); // 500 mS\n                // Reset Retries Counter To Give Full Amount Of Retries\n                retriesCounter = 0;\n                // Retry Original Command\n                continue;\n            }\n            else { // Errors Returned\n                // Increment Retries Counter\n                retriesCounter++;\n                // Short Pause Between Retry Attempts\n                basic.pause(5); // Was 200 mS\n            }\n        }\n        // What To Do If Comms Are Unsuccessful Still ?\n    }\n}"}]},{"timestamp":1751448078694,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".ts\""],[-1,",\n        \"test.ts\""],[0,"\n   "]],"start1":236,"start2":236,"length1":27,"length2":8}]},{"type":"added","filename":"test.ts","value":""}]},{"timestamp":1751448121825,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":111}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":263,"start2":263,"length1":52,"length2":8}]},{"type":"edited","filename":"test.ts","patch":[{"diffs":[[-1,"// Test program for the Kitronik Mai-Z the Mouse Bot\n// This exercises all features on Mai-Z, along with all the blocks in the Mai-Z extension.\n\n// Test Variables\nlet RightLineFollowSensor = false\nlet CliffDetectionStatus = false\nlet FrontDistance = 0\n\n// Infinite Test Loop\nbasic.forever(function () {\n    // Movement Commands\n    kitronikMaiZ.maizMove(kitronikMaiZ.MoveDirection.Forwards, 50, kitronikMaiZ.MoveDistance.TenUnits)\n    kitronikMaiZ.maizRotateAngle(90, 50)\n    kitronikMaiZ.maizRotateContinuous(kitronikMaiZ.RotateDirection.Clockwise, 50)\n    basic.pause(2000)\n    kitronikMaiZ.maizStop()\n    kitronikMaiZ.maizMove(kitronikMaiZ.MoveDirection.Forwards, 50, kitronikMaiZ.MoveDistance.Continuous)\n    basic.pause(2000)\n    kitronikMaiZ.maizGradualStop()\n    kitronikMaiZ.maizMoveTiles(kitronikMaiZ.MoveXTiles.OneTile, 50)\n    kitronikMaiZ.maizTurnTiles(kitronikMaiZ.TurnTiles.TurnRight)\n    kitronikMaiZ.maizUTurn()\n\n    // LED Commands\n    kitronikMaiZ.setLEDs(0x0000ff)\n    kitronikMaiZ.setLED(kitronikMaiZ.LedID.ledOne, 0xff0000)\n    kitronikMaiZ.setLEDBrightness(50)\n    kitronikMaiZ.setIndicatorLights(kitronikMaiZ.IndicatorStatus.Left)\n    kitronikMaiZ.setBrakeLights(kitronikMaiZ.BrakeStatus.On)\n    basic.pause(2000)\n    kitronikMaiZ.setIndicatorLights(kitronikMaiZ.IndicatorStatus.Off)\n    kitronikMaiZ.setBrakeLights(kitronikMaiZ.BrakeStatus.Off)\n\n    // Sensor Commands\n    RightLineFollowSensor = kitronikMaiZ.lineFollowStatus(kitronikMaiZ.LineFollowSensor.Right)\n    CliffDetectionStatus = kitronikMaiZ.cliffDetectionStatus()\n    kitronikMaiZ.autoCliffDetection(kitronikMaiZ.AutoCliffStatus.Disabled)\n    FrontDistance = kitronikMaiZ.measureFrontDistance()\n\n    // Buzzer Commands\n    kitronikMaiZ.soundBuzzer()\n\n    // Units Commands\n    kitronikMaiZ.unitsSelect(kitronikMaiZ.SelectUnits.Cm)\n})"]],"start1":0,"start2":0,"length1":1820,"length2":0}]}]}],"snapshots":[{"timestamp":1751447022212,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Mai-Z\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1751448266923}